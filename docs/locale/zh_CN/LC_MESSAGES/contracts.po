# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, sCrypt Inc
# This file is distributed under the same license as the sCrypt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# qtom zheng <zhfnjust@qq.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: sCrypt\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-29 09:04+0800\n"
"PO-Revision-Date: 2021-10-07 06:10+0000\n"
"Last-Translator: qtom zheng <zhfnjust@qq.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/scrypt-1/teams/121283/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../contracts.rst:3 ../../contracts.rst:90
#: 134728ec8b6046b6bb8bdfee69be6f51 b0ddadacffb24a658040cca2222d3811
msgid "Standard Contracts"
msgstr "标准合约"

#: ../../contracts.rst:6 25d5e619c2ab44539201c6b8f1948cee
msgid "Multiple Contracts"
msgstr "多个合约"

#: ../../contracts.rst:7 8d95b90f59c14935b39e6bad84899e58
msgid ""
"A single file can define multiple contracts. In this case, the last contract"
" acts as the main contract and is what gets compiled. Other contracts are "
"dependencies."
msgstr "一个文件可以定义多个合约。在这种情况下，最后一个合约作为主合约并且被编译。其他合约是依赖项。"

#: ../../contracts.rst:10 10c7afe45d5741dbb37f26c85cee7976
msgid ""
"In the following example, a standard P2PKH contract is rewritten using two "
"other contracts: a hash puzzle contract that checks the public key matches "
"the public key hash, and a Pay-to-PubKey (P2PK) contract that verifies "
"signature matches public key."
msgstr ""
"在下面这个例子中，标准的P2PKH合约被改写为两个其他合约：一个用来检查公钥和公钥哈希是否匹配的哈希谜题（hash puzzle）合约"
"，还有一个检查签名和公钥是否匹配的Pay-to-PubKey（P2PK）合约。"

#: ../../contracts.rst:44 15a402754ac041198d6ad6e746c460bf
msgid "import"
msgstr "导入（import）"

#: ../../contracts.rst:45 8f939f4bcf3341958e0fb755e89dcb2b
msgid ""
"Alternatively, the contract above can be broken into three files. The "
"``Pay2PubKeyHash`` contact ``import``\\s other two contracts as "
"dependencies. This allows reusing contracts written by others and forms the "
"basis of contract libraries."
msgstr ""
"或者，可以将上述合约分到三个文件中。 ``Pay2PubKeyHash`` 合约 ``import`` "
"其他两个合约作为依赖。这就可以重用其他人写的合约，成为构建合约库的基础。"

#: ../../contracts.rst:48 e0a4eea317f4487e92c3f83578c19113
msgid ""
"A contract can be instantiated by ``new``. A ``public`` function can be "
"called from ``require``, which takes boolean expression as input."
msgstr ""
"合约可以通过 ``new`` 来实例化。``require`` 函数的参数是条件表达式， 调用合约的 ``public`` 函数可以作为条件表达式传入。"

#: ../../contracts.rst:68 366f714b888d4f9b9f7301d37a08cae0
msgid "Library"
msgstr "Library 库"

#: ../../contracts.rst:69 4fc6664e9799410991499937dd4d0ba5
msgid ""
"A library is the same with a contract, except it does not contain any public"
" function. It is only intended to be imported by a contract or other "
"libraries. It thus cannot be independently deployed and called. It is "
"frequently used to group related constants and static functions."
msgstr "库与合约相同，只是它不包含任何公共函数。它仅用于由合约或其他库导入。因此它不能被独立部署和调用。它经常用于对相关常量和静态函数进行分组。"

#: ../../contracts.rst:91 1210614e82c1489fa0d59dbb640ad071
msgid ""
"sCrypt comes with standard libraries that define many commonly used "
"contracts. They are included by default and do not require explicit "
"``import`` to be used."
msgstr "sCrypt自带标准库，里面定义了许多常用的合约。标准库是默认就导入的，不需要写 ``import`` 语句。"

#: ../../contracts.rst:93 bc6237b311de4b37acfe38eaef89a52f
msgid ""
"The following example shows usage of the standard contract ``P2PKH`` that "
"corresponds to Pay-to-PubKey-Hash contract."
msgstr "如下例子展示了对标准合约 ``P2PKH`` 的使用。"

#: ../../contracts.rst:109 6ad4e49c77af43ee8ce63ba77493e187
msgid "Contract ``OP_PUSH_TX``"
msgstr "``OP_PUSH_TX`` 合约"

#: ../../contracts.rst:110 e11f82af44c54a17bab571543ec0b436
msgid ""
"One grave misconception regarding bitcoin script is that its access is only "
"limited to the data provided in the locking script and corresponding "
"unlocking script. Thus, its scope and capability are greatly underestimated."
msgstr "对比特币脚本的一个严重误解是，脚本只能访问锁定脚本以及对应的解锁脚本中提供的数据。因此，脚本的范围和能力被大大低估了。"

#: ../../contracts.rst:113 54c66a7a35694efba0b1384559f7b617
msgid ""
"sCrypt comes with a powerful contract called ``Tx`` that allows inspection "
"of the **ENTIRE TRANSACTION** containing the contract itself, besides the "
"locking script and unlocking script. It can be regarded as a pseudo opcode "
"``OP_PUSH_TX`` that pushes the current transaction into the stack, which can"
" be inspected at runtime. More precisely, it enables inspection of the "
"preimage used in signature verification defined in `BIP143`_. The format of "
"the preimage is as follows:"
msgstr ""
"sCrypt提供了一个强大的合约叫做 ``Tx``。 它允许合约访问合约所在的 整个交易 ，包括锁定脚本和解锁脚本。我们把这种方法当成一个伪操作码 "
"``OP_PUSH_TX`` ，它可以把当前交易压到栈里，这样就可以在运行时访问了。 更准确地说，可以访问的是在签名校验时用到的原像 preimage "
"， 在 `BIP143`_. 中有原像的详细定义。原像的数据格式如下："

#: ../../contracts.rst:118 ac9831805b294d35a5cf6d05d8020923
msgid "nVersion of the transaction (4-byte little endian)"
msgstr " nVersion of the transaction  (交易的版本号,  4字节小端)"

#: ../../contracts.rst:119 3b6f1370506340429d2491aac7c126e8
msgid "hashPrevouts (32-byte hash)"
msgstr "hashPrevouts (输入的输出点哈希 32字节哈希值)"

#: ../../contracts.rst:120 ca1174f437dd460698c5c2d263f2a31f
msgid "hashSequence (32-byte hash)"
msgstr "hashSequence (序列号哈希 32字节哈希值)"

#: ../../contracts.rst:121 049d8341f97f40aaa162e325c0ebd6a5
msgid "outpoint (32-byte hash + 4-byte little endian)"
msgstr "outpoint (此输入的输出点 32字节哈希值 + 4字节小端）"

#: ../../contracts.rst:122 8c6be3064ec04604ba4041c3705b8523
msgid "scriptCode of the input (serialized as scripts inside CTxOuts)"
msgstr "scriptCode of the input (输入对应的UTXO的锁定脚本)"

#: ../../contracts.rst:123 7d708ed958884cab8553f3a4f9e22718
msgid "value of the output spent by this input (8-byte little endian)"
msgstr "value of the output spent by this input (此输入对应的输出中包含的聪数 8字节小端)"

#: ../../contracts.rst:124 4f8a172c99e4447c8e3f8593c13a1474
msgid "nSequence of the input (4-byte little endian)"
msgstr "nSequence of the input (此输入的序列号 4字节小端)"

#: ../../contracts.rst:125 2b4c7575216b4eacaf62fc78c86ca034
msgid "hashOutputs (32-byte hash)"
msgstr "hashOutputs (输出的哈希 32字节哈希值)"

#: ../../contracts.rst:126 5c2a9b4152e0481292579f4de6c8b1cf
msgid "nLocktime of the transaction (4-byte little endian)"
msgstr "nLocktime of the transaction (交易的nLocktime 4字节小端)"

#: ../../contracts.rst:127 5403c63d369c42daa7f4a4bd66877722
msgid "sighash type of the signature (4-byte little endian)"
msgstr "sighash type of the signature (签名类型 4字节小端)"

#: ../../contracts.rst:129 d0e8952d29e441f08def46a75a8e4096
msgid ""
"As an example, contract ``CheckLockTimeVerify`` ensures coins are timelocked"
" and cannot be spent before ``matureTime`` is reached, similar to "
"`OP_CLTV`_."
msgstr ""
"例如，合约 ``CheckLockTimeVerify`` 确保合约中的币是时间锁定的，并且不能在时间达到 ``matureTime`` "
"之前花费，类似于 `OP_CLTV`_。"

#: ../../contracts.rst:153 c6d73b9e75434d659cbb472b88f657d4
msgid ""
"More details can be found in this article `OP_PUSH_TX`_. To customize ECDSA "
"signing, such as choosing ephemeral key, there is a more general version "
"called ``Tx.checkPreimageAdvanced()``. see `Advanced OP_PUSH_TX`_."
msgstr ""
"更多细节可以在这篇文章 `OP_PUSH_TX 技术`_ 中找到。要自定义 ECDSA 签名，例如选择临时密钥，有一个更通用的版本，称为 "
"``Tx.checkPreimageAdvanced()`` 。请参阅 `高级 OP_PUSH_TX 技术`_。"

#: ../../contracts.rst:157 159ed79c4e984e26b14a738f51677411
msgid "Library ``HashedMap``"
msgstr "``HashedMap`` 库"

#: ../../contracts.rst:159 ea592b8df43548e1b3558e99fd3cf220
msgid ""
"The `HashedMap` library provides a map/hashtable-like data structure. Unique"
" keys and their corresponding values are hashed before being stored. Most "
"functions of `HashedMap` require not only a key, but also its index, ranked "
"by key hash in ascending order."
msgstr ""
"`HashedMap` 库提供了一种类似于哈希表的数据结构。唯一键和它们对应的值在存储之前被散列。 `HashedMap` "
"的大多数函数不仅需要一个键，还需要它的索引，按键的哈希升序排列。"

#: ../../contracts.rst:163 ../../contracts.rst:239
#: 1c404092032e4a89a09aeb899841b3c6 1c404092032e4a89a09aeb899841b3c6
msgid "**Constructor**"
msgstr "**构造函数**"

#: ../../contracts.rst:165 61dba7e8b0b84439b5a4b75ddb269623
msgid ""
"``HashedMap(bytes data)`` Create an instance of ``HashedMap`` with some "
"initial data."
msgstr "``HashedMap(bytes data)`` 使用一些初始数据创建一个 ``HashedMap`` 实例。"

#: ../../contracts.rst:176 ../../contracts.rst:257
#: 53d63e8f03844b7a9d22d29baa820e4c cc27c0b791a54743b7bcce36d88cae4d
msgid "**Instance methods**"
msgstr "**实例方法**"

#: ../../contracts.rst:178 5a1c6582f1ab4f7ebabbba38d215ef52
msgid ""
"``set(K key, V val, int keyIndex) : bool`` Insert or update a (`key`, `val`)"
" pair with the key index given by `keyIndex`. Returns `true` if successful; "
"otherwise returns `false`."
msgstr ""
"``set(K key, V val, int keyIndex) : bool`` 使用给出的键索引 `keyIndex` 插入或更新 (`key`,"
" `val`) 对。如果成功则返回  `true` ；否则返回 `false` 。"

#: ../../contracts.rst:186 84067550dec0414ca47403837ce276d6
msgid ""
"``canGet(K key, V val, int keyIndex): bool`` Check whether we can get a "
"(`key`, `val`) pair with the key index given by `keyIndex`. Returns `true` "
"if successful; otherwise returns `false`."
msgstr ""
"``canGet(K key, V val, int keyIndex): bool``  通过键索引 `keyIndex` 检查我们是否可以得到一个 "
"(`key`, `val`) 对。如果成功则返回 `true` ；否则返回 `false`。"

#: ../../contracts.rst:193 d506e5928f5341cb9f852bf90673e2a1
msgid ""
"``has(K key, int keyIndex) : bool`` Check whether `key` exists in the map "
"and its index is `keyIndex`. Returns `true` if both conditions are met; "
"otherwise returns `false`."
msgstr ""
"``has(K key, int keyIndex) : bool`` 检查 HashedMap 中是否存在 `key`，其索引为 "
"`keyIndex`。如果两个条件都满足，则返回 `true`；否则返回 `false`。"

#: ../../contracts.rst:200 516472437d144395ab12eeca47a9ea09
msgid ""
"``delete(K key, int keyIndex) : bool`` Delete the entry with given `key` and"
" the key index is `keyIndex`. Returns `true` if successful; otherwise "
"returns `false`."
msgstr ""
"``delete(K key, int keyIndex) : bool`` 删除给定 `key` 的条目，并且键索引是 `keyIndex` "
"。如果成功则返回`true`；否则返回 `false`。"

#: ../../contracts.rst:207 21d9c29ff361427088e170a9bbef1fba
msgid "``clear() : bool`` Delete all entries of the map."
msgstr "``clear() : bool`` 删除map的所有条目。"

#: ../../contracts.rst:214 d96e445186ce4e338ea3d105c37c82a9
msgid ""
"``size() : int`` Returns the size of map, i.e. the number of the keys it "
"contains."
msgstr "``size() : int`` 返回 HashedMap 的大小，比如它包含的键的数量。"

#: ../../contracts.rst:222 21d9c29ff361427088e170a9bbef1fba
msgid ""
"``data() : bytes`` Returns the internal data representation of the map."
msgstr "``data() : bytes`` 返回 HashedMap 的序列化数据表示。"

#: ../../contracts.rst:232 5fc6893102a2491f82068dac830151d9
msgid "Library ``HashedSet``"
msgstr "``HashedSet`` 库"

#: ../../contracts.rst:234 96b1f10b53af4589814af923e76c5860
msgid ""
"The `HashedSet` library provides a set-like data structure. It can be "
"regarded as a special `HashedMap` where a value is the same with its key and"
" is thus omitted. Unique values are hashed before being stored. Most "
"functions of `HashedSet` require an index, ranked by the value's sha256 hash"
" in ascending order."
msgstr ""
"`HashedSet` 库提供了一个类似集合的数据结构。它可以被视为一个特殊的 "
"`HashedMap`，即键值对的值与其键相同，因此被省略。唯一值在存储之前被散列。 `HashedSet` 的大多数函数都需要一个索引，按值的 "
"sha256 哈希值升序排列。"

#: ../../contracts.rst:241 abffff7878bf45cb9798c52163c8e234
msgid ""
"``HashedSet(bytes data)`` Create an instance of ``HashedSet`` with some "
"initial data."
msgstr "``HashedSet(bytes data)`` 使用初始数据 data 创建一个 ``HashedSet`` 实例。"

#: ../../contracts.rst:259 957561db0c0d4ba883d00c66930f0c6e
msgid ""
"``add(E entry, int index) : bool`` Add `entry` to set with the key index "
"given by `index`. Returns `true` if successful; otherwise returns `false`."
msgstr ""
"``add(E entry, int index) : bool`` 添加具有给定 `entry` 项且索引为 `index` "
"的条目。如果成功则返回“true”；否则返回 `false`。"

#: ../../contracts.rst:266 d032df5e20794e599f4b55ed50383435
msgid ""
"``has(E entry, int index) : bool`` Check whether `entry` exists in the set "
"and its index is `index`. Returns `true` if both conditions are met; "
"otherwise returns `false`."
msgstr ""
"``has(E entry, int index) : bool`` 检查集合中是否存在具有给定 `entry` 项且索引为 `index` "
"的条目。如果两个条件都满足，则返回 `true`；否则返回`false`。"

#: ../../contracts.rst:273 1e79ad0670294010a5a57031bafdd14d
msgid ""
"``delete(E entry, int index) : bool`` Delete the entry with given `entry` "
"and the index is `index`. Returns `true` if successful; otherwise returns "
"`false`."
msgstr ""
"``delete(E entry, int index) : bool`` 删除具有给定 `entry` 项且索引为 `index` "
"的条目。如果成功则返回 `true`；否则返回 `false`。"

#: ../../contracts.rst:280 21d9c29ff361427088e170a9bbef1fba
msgid "``clear() : bool`` Delete all entries of the set."
msgstr "``clear() : bool`` 删除集合的所有条目。"

#: ../../contracts.rst:287 d96e445186ce4e338ea3d105c37c82a9
msgid ""
"``size() : int`` Returns the size of set, i.e. the number of the entries it "
"contains."
msgstr "``size() : int`` 返回集合的大小，即它包含的条目数。"

#: ../../contracts.rst:294 21d9c29ff361427088e170a9bbef1fba
msgid ""
"``data() : bytes`` Returns the internal data representation of the set."
msgstr "``data() : bytes`` 返回集合的内部序列化数据。"

#: ../../contracts.rst:304 f1531513074247cc87f1ff92ced9c248
msgid "Full List"
msgstr "完整列表"

#: ../../contracts.rst:310 9509bbd63ad64b8b90f60f6ef3b65737
msgid "Contract"
msgstr "合约"

#: ../../contracts.rst:311 1c404092032e4a89a09aeb899841b3c6
msgid "Constructor parameters"
msgstr "构造函数参数"

#: ../../contracts.rst:312 2ab447f59b874d65b7fc6f6bdef0da67
msgid "Public function"
msgstr "公共函数"

#: ../../contracts.rst:314 da54e077bd6c46fd93949e6d496a69c3
msgid "P2PKH"
msgstr "P2PKH"

#: ../../contracts.rst:315 c806a07acb244e6d8dc02be17d1e7d3e
msgid "Ripemd160 pubKeyHash"
msgstr "Ripemd160 pubKeyHash"

#: ../../contracts.rst:316 bb2c0cdd4b074474b7bb3e97493acfad
msgid "spend(Sig sig, PubKey pubKey)"
msgstr "spend(Sig sig, PubKey pubKey)"

#: ../../contracts.rst:318 ba18b60de41e403cb31ae5e48ebfa00f
msgid "P2PK"
msgstr "P2PK"

#: ../../contracts.rst:319 f78899d539eb4425be483659352954e7
msgid "PubKey pubKey"
msgstr "PubKey pubKey"

#: ../../contracts.rst:320 8caae54f32a64dd7b0d4358f94496d53
msgid "spend(Sig sig)"
msgstr "spend(Sig sig)"

#: ../../contracts.rst:322 418193a79b0348f5bc4fda04573b12a3
msgid "HashPuzzleX [#]_"
msgstr "HashPuzzleX [#]_"

#: ../../contracts.rst:323 9737cef6d28d437a8157ae5aa7be84c0
msgid "Y [#]_ hash"
msgstr "Y [#]_ hash"

#: ../../contracts.rst:324 20966d76f04d40429febd711d4cdfadf
msgid "spend(bytes preimage)"
msgstr "spend(bytes preimage)"

#: ../../contracts.rst:326 a6995085c8d847fcaa277f2d87c8e008
msgid "Tx"
msgstr "Tx"

#: ../../contracts.rst:327 c66b62308ad1476db8793bfe9e9146ce
msgid "None"
msgstr "None"

#: ../../contracts.rst:328 167e552e074a46f4b0c0f4b6e3c78349
msgid "checkPreimage(bytes sighashPreimage)"
msgstr "checkPreimage(bytes sighashPreimage)"

#: ../../contracts.rst:330 55cf5fdf26734d4ba761d3992dc29e75
msgid "HashedMap<K, V>"
msgstr "HashedMap<K, V>"

#: ../../contracts.rst:331 ../../contracts.rst:341
#: 4cf3a5efbed14713a88e8a9fb394a5c7 4cf3a5efbed14713a88e8a9fb394a5c7
msgid "bytes data"
msgstr "bytes data"

#: ../../contracts.rst:0 b99caa06a56647669c285a2d5e30a18c
msgid "set(K key, V val, int keyIndex)"
msgstr "set(K key, V val, int keyIndex)"

#: ../../contracts.rst:0 dd72bf752b5a4ae887349b010a01500e
msgid "canGet(K key, V val, int keyIndex)"
msgstr "canGet(K key, V val, int keyIndex)"

#: ../../contracts.rst:0 040df4982d35422faa56a1e7662254d5
msgid "delete(K key, int keyIndex)"
msgstr "delete(K key, int keyIndex)"

#: ../../contracts.rst:0 caff9e2b110047e7a3ea736c8aee11e5
msgid "has(K key, int keyIndex)"
msgstr "has(K key, int keyIndex)"

#: ../../contracts.rst:0 ../../contracts.rst:0
#: 1e6aaf580af34f76ac46abaa0f12bd1b cd668318467a4bf59043846af80a47ab
msgid "clear()"
msgstr "clear()"

#: ../../contracts.rst:0 ../../contracts.rst:0
#: 2efca68a9daa42fab257fe59bc1f9993 8e87fbc12dfa44d589a0982f6e6c5f83
msgid "size()"
msgstr "size()"

#: ../../contracts.rst:0 ../../contracts.rst:0
#: 024441d751304887912bebe3a7bf0591 00bd7e16dde64a17ba89ba0856e6125a
msgid "data()"
msgstr "data()"

#: ../../contracts.rst:340 55cf5fdf26734d4ba761d3992dc29e75
msgid "HashedSet<V>"
msgstr "HashedSet<V>"

#: ../../contracts.rst:0 e3a3314a30164cbc98610162c6801071
msgid "add(V val, int index)"
msgstr "add(V val, int index)"

#: ../../contracts.rst:0 b4485855920c47ea9c481af94248cf73
msgid "delete(V val, int index)"
msgstr "delete(V val, int index)"

#: ../../contracts.rst:0 3888fa32eada4b4c91abdc6f0e3bdeae
msgid "has(V val, int index)"
msgstr "has(V val, int index)"

#: ../../contracts.rst:349 a0587126d99c4c489485b762d6a7646e
msgid "``X`` is hashing function and can be Ripemd160/Sha1/Sha256/Hash160"
msgstr "``X`` 是散列函数，可以是 ``Ripemd160/Sha1/Sha256/Hash160``"

#: ../../contracts.rst:350 82acf4fc588a4c76b1b0c3321536b066
msgid ""
"``Y`` is hashing function return type and can be "
"Ripemd160/Sha1/Sha256/Ripemd160"
msgstr "``Y`` 是哈希函数返回类型，可以是 ``Ripemd160/Sha1/Sha256/Ripemd160``"
