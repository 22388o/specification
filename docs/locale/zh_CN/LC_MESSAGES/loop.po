# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, sCrypt Inc
# This file is distributed under the same license as the sCrypt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# qtom zheng <zhfnjust@qq.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: sCrypt\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-08 12:13+0800\n"
"PO-Revision-Date: 2021-10-07 06:10+0000\n"
"Last-Translator: qtom zheng <zhfnjust@qq.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/scrypt-1/teams/121283/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../loop.rst:3 c60c6c86379e486e85010a898cdd8f4c
msgid "Loop"
msgstr "循环"

#: ../../loop.rst:10 be86973054c4442d89ed4342b448d00d
msgid ""
"Bitcoin script does not provide looping constructs natively for security "
"reasons. sCrypt achieves looping by repeating the loop body ``maxLoopCount``"
" times. For example, the loop"
msgstr "出于安全原因，比特币脚本本身不提供循环结构。 sCrypt 通过重复循环体 ``maxLoopCount`` 次来实现循环。例如，循环"

#: ../../loop.rst:20 3f1f3ebf4e3e46a09ee6a9e8e27bfe0f
msgid "is equivalently unrolled to"
msgstr "等效地展开为"

#: ../../loop.rst:36 eee6576194694bcda3444f16bbe5b706
msgid ""
"Because `loop unrolling <https://en.wikipedia.org/wiki/Loop_unrolling>`_ is "
"done at compile time, the compiler must know ``maxLoopCount``. That is, it "
"must be a :ref:`compile time constant<ctc-label>`."
msgstr ""
"因为 `循环展开 <https://en.wikipedia.org/wiki/Loop_unrolling>`_ 是在编译时完成的，编译器必须知道 "
"``maxLoopCount``。也就是说，它必须是一个 :ref:`编译时常量 <ctc-label>`。"

#: ../../loop.rst:39 14e5014941fc41e58f2f2ae53b1e64b4
msgid ""
"If ``maxLoopCount`` is set too small, the contract may not work correctly. "
"If ``maxLoopCount`` is set too large, the resulting script is bloated "
"unnecessarily and costs more to execute. There are a number of ways to "
"choose the right ``maxLoopCount`` judiciously. One way is to simulate the "
"contract off chain and find the number of loops. Another way is to exploit "
"the characteristics of the looping itself. For example, if a loop iterates "
"over each bit of a ``sha256`` hash, ``maxLoopCount`` is ``256``."
msgstr ""
"如果 ``maxLoopCount`` 设置得太小，合约可能无法正常工作。如果 ``maxLoopCount`` "
"设置得太大，生成的脚本会不必要地膨胀，并且执行成本更高。有多种方法可以明智地选择正确的 "
"``maxLoopCount``。一种方法是模拟链下合约并找到循环次数。另一种方法是利用循环本身的特性。例如，如果循环遍历``sha256`` "
"散列的每一位，``maxLoopCount`` 就是 ``256``。"

#: ../../loop.rst:46 951a7dec60db452da13e83b1932f7fbc
msgid "Induction variable"
msgstr "归纳变量 (Induction Variable)"

#: ../../loop.rst:47 3ed59c66d5224b31a8b11c228567d312
msgid ""
"`Induction variable <https://en.wikipedia.org/wiki/Induction_variable>`_ can"
" be defined when loop index is needed."
msgstr ""
"`归纳变量 <https://en.wikipedia.org/wiki/Induction_variable>`_ 可以在需要循环索引时定义。"

#: ../../loop.rst:62 79240b139d37449896d81ac40a52a309
msgid "Conditional loop"
msgstr "条件循环"

#: ../../loop.rst:73 06d7a9d40d40408794564856b56665e4
msgid "break"
msgstr "跳出循环"
