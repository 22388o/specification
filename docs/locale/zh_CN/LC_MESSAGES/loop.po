# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019, sCrypt Inc
# This file is distributed under the same license as the sCrypt package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# qtom zheng <zhfnjust@qq.com>, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: sCrypt\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-07 22:30+0800\n"
"PO-Revision-Date: 2021-10-07 06:10+0000\n"
"Last-Translator: qtom zheng <zhfnjust@qq.com>, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/scrypt-1/teams/121283/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../loop.rst:3 986685fcfc1749ff84f3d2ebb75b6bb4
msgid "Loop"
msgstr "循环"

#: ../../loop.rst:10 1ee647ebadaf4287b823960da120c9d7
msgid ""
"Bitcoin script does not provide looping constructs natively for security "
"reasons. sCrypt achieves looping by repeating the loop body ``maxLoopCount``"
" times. For example, the loop"
msgstr "出于安全原因，比特币脚本本身不提供循环结构。 sCrypt 通过重复循环体 ``maxLoopCount`` 次来实现循环。例如，循环"

#: ../../loop.rst:20 11a6cdfa329d4ba695223e26fbea24c0
msgid "is equivalently unrolled to"
msgstr "等效地展开为"

#: ../../loop.rst:36 443ea9186a8743058abf984b4f5dad8f
msgid ""
"Because `loop unrolling <https://en.wikipedia.org/wiki/Loop_unrolling>`_ is "
"done at compile time, the compiler must know ``maxLoopCount``. That is, it "
"must be a :ref:`compile time constant<ctc-label>`."
msgstr ""
"因为`循环展开 <https://en.wikipedia.org/wiki/Loop_unrolling>`_ "
"是在编译时完成的，编译器必须知道``maxLoopCount``。也就是说，它必须是一个 :ref:`编译时常量 <ctc-label>`。"

#: ../../loop.rst:39 3793e55162674f2082792ea8aa64a1ef
msgid ""
"If ``maxLoopCount`` is set too small, the contract may not work correctly. "
"If ``maxLoopCount`` is set too large, the resulting script is bloated "
"unnecessarily and costs more to execute. There are a number of ways to "
"choose the right ``maxLoopCount`` judiciously. One way is to simulate the "
"contract off chain and find the number of loops. Another way is to exploit "
"the characteristics of the looping itself. For example, if a loop iterates "
"over each bit of a ``sha256`` hash, ``maxLoopCount`` is ``256``."
msgstr ""
"如果 ``maxLoopCount`` 设置得太小，合约可能无法正常工作。如果 ``maxLoopCount`` "
"设置得太大，生成的脚本会不必要地膨胀，并且执行成本更高。有多种方法可以明智地选择正确的 "
"``maxLoopCount``。一种方法是模拟链下合约并找到循环次数。另一种方法是利用循环本身的特性。例如，如果循环遍历``sha256`` "
"散列的每一位，``maxLoopCount`` 就是 ``256``。"

#: ../../loop.rst:46 5c82b1ca19744676a87305cba0b9874c
msgid "Induction variable"
msgstr "归纳变量 (Induction Variable)"

#: ../../loop.rst:47 057fdc9e1942419cb56dc64a601daddc
msgid ""
"`Induction variable <https://en.wikipedia.org/wiki/Induction_variable>`_ can"
" be defined when loop index is needed."
msgstr ""
"`归纳变量 <https://en.wikipedia.org/wiki/Induction_variable>`_ 可以在需要循环索引时定义。"

#: ../../loop.rst:62 87e0cdd9a0cd4bcfb7a441288e621f04
msgid "Conditional loop"
msgstr "条件循环"

#: ../../loop.rst:73 b8554f420278429cb186f6e75cf540b7
msgid "break"
msgstr "跳出循环"
